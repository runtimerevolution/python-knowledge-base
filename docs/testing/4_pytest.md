# Pytest

> this document was inspired/copied from of [https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html) and 
> [https://docs.djangoproject.com/en/4.1/topics/testing/overview/](https://docs.djangoproject.com/en/4.1/topics/testing/overview/)

Pytest is a Python testing framework that originated from the PyPy project. It can be used to write various types of 
software tests, including unit tests, integration tests, end-to-end tests, and functional tests. Its features include 
parametrized testing, fixtures, and assert re-writing.

## Anatomy of a test

Pytest divides a test into four steps:

- **Arrange** is where we prepare everything for our test. This means pretty much everything except for the “act”.
This can mean preparing objects, starting/killing services, entering records into a database, or even things like 
defining a URL to query, generating some credentials for a user that doesn't exist yet, or just waiting for some 
process to finish.
- **Act** is the singular, state-changing action that kicks off the behavior we want to test. This typically takes the 
form of a function/method call.
- **Assert** is where we take that measurement/observation on our test and apply our judgement to it.
- **Cleanup** is where the test picks up after itself, so other tests aren’t being accidentally influenced by it.

````python
import pytest

class TestStringMethods:  # A testcase
    
    # The individual tests are defined with methods whose names start with the 
    # letters test. This naming convention informs the test runner about which methods 
    # represent tests.
    def test_upper(self):  
        assert 'foo'.upper() == 'FOO'

    def test_isupper(self):
        assert 'FOO'.isupper() is True
        assert 'Foo'.isupper() is False

    def test_split(self):
        s = 'hello world'
        assert s.split() == ['hello', 'world']
        # check that s.split fails when the separator is not a string
        with pytest.raises(TypeError):
            s.split(2)
````

### Fixture

Fixtures are each of the **arrange** steps and data.

````python
import pytest


class Fruit:
    def __init__(self, name):
        self.name = name

    def __eq__(self, other):
        return self.name == other.name


@pytest.fixture
def my_fruit():
    return Fruit("apple")


@pytest.fixture
def fruit_basket(my_fruit):
    return [Fruit("banana"), my_fruit]


def test_my_fruit_in_basket(my_fruit, fruit_basket):
    assert my_fruit in fruit_basket
````

#### Fixture scopes

Fixtures are created when first requested by a test, and are destroyed based on their scope:

- **function**: the default scope, the fixture is destroyed at the end of the test.
- **class**: the fixture is destroyed during teardown of the last test in the class.
- **module**: the fixture is destroyed during teardown of the last test in the module.
- **package**: the fixture is destroyed during teardown of the last test in the package.
- **session**: the fixture is destroyed at the end of the test session.

```python
@pytest.fixture(scope="session")
def smtp_connection():
    # the returned fixture value will be shared for
    # all tests requesting it
    ...
```

### Command Line

The pytest module can be used from the command line to run tests from modules, classes or even individual test
methods:

```bash
pytest test_module1 test_module2
pytest test_module.TestClass
pytest test_module.TestClass.test_method
```

For a list of all the command-line options:

```bash
pytest -h
```

## Assertions

Pytest allows you to use the standard Python **assert** for verifying expectations and values in Python tests.

### Custom error message

Assert supports a message, which should be used to make assert statements more clear. 

````python
import pytest

class TestStringMethods:
    def test_upper(self):  
        assert 'foo'.upper() == 'FOO', "Test string uppercase equal"

    def test_isupper(self):
        assert 'FOO'.isupper() is True, "Test string uppercase True"
        assert 'Foo'.isupper() is False, "Test string uppercase False"

    def test_split(self):
        s = 'hello world'
        assert s.split() == ['hello', 'world'], "Test split string"

        with pytest.raises(TypeError, match="must be str or None, not int"):
            s.split(2)
````

## Anatomy of a Django test

```python
from django.test import TestCase  # is a subclass of unittest.TestCase that 
                                  # runs each test inside a transaction to provide isolation
from myapp.models import Animal

class AnimalTestCase(TestCase):
    # Django provides an additional way of defining fixtures
    # these can be generated by running:
    #    python manage.py dumpdata animal_app.Status -o animal_app/fixtures/initial_data/status.json
    fixtures = ["animal_app/fixtures/initial_data/status.json",]
    
    def setUp(self):
        # the unittest way of defining fixtures
        Animal.objects.create(name="lion", sound="roar")
        Animal.objects.create(name="cat", sound="meow")

    # The individual tests are defined with methods whose names start with the 
    # letters test. This naming convention informs the test runner about which methods 
    # represent tests.
    def test_animals_can_speak(self):
        """Animals that can speak are correctly identified"""
        lion = Animal.objects.get(name="lion")
        cat = Animal.objects.get(name="cat")
        self.assertEqual(lion.speak(), 'The lion says "roar"')
        self.assertEqual(cat.speak(), 'The cat says "meow"')
```

The default behavior of the test utility is to find all the test cases (that is, subclasses of unittest.TestCase) in
any file whose name begins with test, automatically build a test suite out of those test cases, and run that suite.

### Django models in tests

If your tests rely on database access such as creating or querying models, be sure to create your test classes as 
subclasses of **django.test.TestCase** rather than **unittest.TestCase**.

### Test execution order

Using unittest.TestCase avoids the cost of running each test in a transaction and flushing the database, but if your
tests interact with the database their behavior will vary based on the order that the test runner executes them. This
can lead to unit tests that pass when run in isolation but fail when run in a suite.

### Command Line

Similarly to what happens with unittest, Django allows the same functionality where a module can be used from the 
command line to run tests from modules, classes or even individual test methods.

The example below show how tests can be executed from the most general, which runs all the tests, to the most 
particular, where only one individual test is executed.

```bash
python manage.py test
python manage.py test animal_app.tests.AnimalTestCase
python manage.py test animal_app.tests.AnimalTestCase.test_animals_can_speak
```

#### Preserve database between test execution

The test **--keepdb** option preserves the test database between test runs. It skips the create and destroy actions 
which can greatly decrease the time to run tests.

```bash
python manage.py test --keepdb
```

#### Automatically recover from a test run that was forcefully interrupted

If a test run is forcefully interrupted, the test database may not be destroyed. On the next run, you’ll be asked 
whether you want to reuse or destroy the database. Use the test **--noinput** option to suppress that prompt and 
automatically destroy the database. This can be useful when running tests on a continuous integration server where 
tests may be interrupted by a timeout, for example.

```bash
python manage.py test --noinput
```

